#include "hyreach_utils.h"

#define FLOWPIPE_VERBOSE

namespace hypro
{
    
    /*
    * This class describes a part of a flowpipe which has been generated by a specific location of an hybrid automaton.
    */     
    class FlowpipeSegment
    {
      private:
		location* generatingLocation;   // Location responsible for the existence of this flowpipeSegment
		transition* previousTransition =0; // Transition that has been taken in order to enter the location which generated this flowpipeSegment
		
	  public:
             
        unsigned int startTimestep;     // Number of the timestep responsible for the first set in this flowpipe
             
        matrix_t<double> sets;     // Every column describes a set of the flowpipe
                                        // public to be accessible directly by the algorithms filling the matrix with values
        /*
        * Constructor: initializes the object representing an empty segment of a flowpipe
        */
        FlowpipeSegment(location* generatingLocation, unsigned int startTimestep, unsigned int numberOfDirections, unsigned int timeHorizon)
        {
            this->generatingLocation = generatingLocation;
            this->startTimestep = startTimestep;
            sets = matrix_t<double>::Zero(1,1);
            this->sets.resize(numberOfDirections, timeHorizon+1);
        }    
         
        FlowpipeSegment(location* generatingLocation, transition* generatingTransition, unsigned int startTimestep, unsigned int numberOfDirections, unsigned int timeHorizon): FlowpipeSegment(generatingLocation, startTimestep, numberOfDirections, timeHorizon)
        {
            this->previousTransition = generatingTransition;
        } 
         
        /*
        * returns the set with the specified index from the flowpipe
        */ 
        matrix_t<double> getSet(unsigned int index)
        {
            if(index < (unsigned int)sets.cols() )
            {
                return sets.col(index);
            }
            else
            {
                std::cout<< "!!!! Attempt to get a set with an index from the flowpipe which is not there" << BL;
                matrix_t<double> result(1,1);    // will hopefully lead to errors
                result(0,0) = 0;
                return result;
            }
        } 
         
        /*
        * Adds the complete evaluation of a set at the specified position (column) in the sets matrix of this object
        */ 
        void addSetAtPosition(double* set_descriptor, unsigned int position)
        {
   /*          #ifdef FLOWPIPE_VERBOSE
                 std::cout << "addSetAtPosition: " << position << BL;
             #endif
  */          if(position < (unsigned int)sets.rows())
              {
  /*                       #ifdef FLOWPIPE_VERBOSE
                             std::cout << "valid position" << BL;
                         #endif
                         
                         #ifdef FLOWPIPE_VERBOSE
                             std::cout << "sets: rows() = " << sets.rows() << BL << "sets: cols() = " << sets.cols() << BL;
                         #endif
  */                       
                         for(int i=0; i<sets.rows(); i++)
                         {
                              sets(i,position) = set_descriptor[i];        
                         }
  /*                       #ifdef FLOWPIPE_VERBOSE
                             std::cout << "new entry: " << BL;
                             std::cout << sets.block(0,position,sets.rows(),1) << BL;
                         #endif
  */           }
        }
        
        /*
        * Getter for the location which generated this FlowpipeSegment
        */
        location* getLocation()
        {
            return generatingLocation;
        }
        
        unsigned int size()
        {
            //return (unsigned int) sets.size();
            return (unsigned int) sets.cols();
        }
         
        unsigned int  getLastTimestep()
        {
            return startTimestep + ((unsigned int) sets.size());
        }
    };
}
