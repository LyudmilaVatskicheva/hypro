\subsection{Adaptation of Fukuda's algorithm for polyhedra}

\subsubsection{Converting to positive coordinates and detecting the linealy space}

Knowing a vertex of a polyhedron allows to find an affine transformation which sends it in the positive orthant. The process is to map the vertex to the origin and the normals of the hyperplanes defining it to the canonical base by respectively a translation and a change of basis.

Finding a vertex of the polyhedron is done using a dictionary like with the first phase of the general simplex seen in section~\ref{section_altsimplex}. In fact, obtaining a cobasis composed only by slack variables pushed to their bounds with all the other variables in their bounds gives a dictionary that describes a vertex of the polyhedron. Here the row corresponding to the cost function and the column corresponding to the constants are not used.


To do so, the first thing is to build a dictionary and to reach the feasible area, to check for emptiness. This is exactly the first phase of the simplex. Then, since the cobasis has to be composed only by slack variables, all the original variables in the cobasis are pivoted with a suitable slack variable (the corresponding coefficient has to be non null) but the assignments are not changed: it could bring the dictionary out of the polyhedron. 
\paragraph*{Detection of the linealty space:} If an original variable has no suitable slack variable to be exchanged with, it means this variable has no influence on the distance to each constrains, there is a line included in the polyhedron: a linealty space has been found. To overcome this problem, two constrains are added with opposed normal vectors, their directions being the linealty space's one, and the constant is zero for both, which might implies to reach again the feasible area once all the linealty direction are found. This provides a suitable slack variable to pivot around and the linealty space is saved, the example~\ref{ex_detect_linalty} illustrate this procedure. A cobasis full of slack variables means there exists enough independent constrains to define a vertex and there is no linealty space left.

\begin{example}
	Let's consider the following dictionary (the constrains does not matter for the linealty space detection):
	\begin{tabular}{| c | c | c | c  c |}
	\hline	
	$x$ & $y$ & $s_1$ & & \\
	$\downarrow$ & $\downarrow$ & $\downarrow$ & & \\
	\hline
	\hline	
   	$2$ & $1$ & $0$ & = & $z$ \\ \hline	
   	$0$ & $1$ & $2$ & = & $s_2$\\ \hline 
 	\end{tabular}.\\
 	The objective is to put $x$ in the cobasis, which is not possible. In fact, for any value of $x$, there is a suitable $z$ such that the current point is inside the feasible area: $z=2x$ is the equation of a linealty direction.\\
 	The constrain to add has $(1,0,2)$ as normal vector, the problem is it has to be expressed in term of $(x,y,s_1)$. The method is to add $2$ times (the coefficient corresponding to z) the value of $z$, in the end the normal vector to add is $(5,2,0)$ and the dictionary becomes:
 	\begin{tabular}{| c | c | c | c  c |}
	\hline	
	$x$ & $y$ & $s_1$ & & \\
	$\downarrow$ & $\downarrow$ & $\downarrow$ & & \\
	\hline
	\hline	
   	$2$ & $1$ & $0$ & = & $z$ \\ \hline	
   	$0$ & $1$ & $2$ & = & $s_2$\\ \hline 
   	$5$ & $2$ & $0$ & = & $s_+$\\ \hline 
   	$-5$ & $-2$ & $0$ & = & $s_-$\\ \hline 
 	\end{tabular}.
 	\label{ex_detect_linalty}
\end{example}

The last thing is pushing one by one the variables of the cobasis to their bounds. If doing so would make other variables violate their bounds, the variable is exchanged with the one which bound would be violated first, the latter is then set to its bound (note that the original variables have no bounds). A vertex is found with the hyperplanes that define it.


\subsubsection{Cone detection in Fukuda's algorithm}

Here the problem is reduced to the vertex enumeration of a potentially unbounded polyhedon in the positive orthant. Fukuda's algorithm allows to explore all the vertices. The unbounded side does not bother the algorithm: it just switches between the constrains, unboundedness is just a lack of constrain.

\begin{proposition}
Every non redundant vector of the cone lies in the intersection of $d-1$ linearly independent half-spaces which intersection with a $d_{th}$ provides a vertex of the polyhedron.
\label{prop_cone}
\end{proposition}

The proposition~\ref{prop_cone} states that to find all the vectors of the cone, it is sufficient to check every vertex for the existence of a conic direction, i.e. directions such that $n-1$ independent constrains are saturated. Fukuda's algorithm explores the polyhedron and finds all the possible arrangement of constrains that defines the vertices, thus for every definition of a vertex, the dictionary is check for the existence of a cobasic variable that can be increased while not decreasing any other (not getting closer from an other constrain) and which decreases the objective function (not getting closer from an axis). Conversely, a vector found this way is a ray included in the polyhedron: it belong to the cone. The rays can be output several times, a suppression of the duplicates is done. The example~\ref{ex_detec_cone} detects the vertices and the cones according to this procedure.

\begin{example}
	Sole constrain: $x-y\leq 2$.
	The initial dictionary:
	\begin{tabular}{| c | c || c || c c |}
	\hline	
	$x$ & $y$ & const & & \\
	$\downarrow$ & $\downarrow$ &$\downarrow$  & & \\
	\hline
	\hline		
   	$-1$ & $1$ & $2$ & = & $s_1$\\ \hline \hline	
   	$-1$ & $-1$ & $0$ & $\leftarrow$ & obj  \\
   	\hline
   	\end{tabular}. This dictionary gives $0$ as a vertex. Concerning the cones, as $s_1$ would be decreasing, $x$ does not provides a cone direction, yet $y$ does: the objective is decreased and $s_1$ increases: $(0,1)$ is a cone direction.\\
   	The next (and last) dictionary to explore is obtained by pivoting $x$ and $s_1$:
   	\begin{tabular}{| c | c || c || c c |}
	\hline	
	$s_1$ & $y$ & const & & \\
	$\downarrow$ & $\downarrow$ &$\downarrow$  & & \\
	\hline
	\hline		
   	$-1$ & $1$ & $2$ & = & $x$\\ \hline \hline	
   	$1$ & $-2$ & $-2$ & $\leftarrow$ & obj  \\
   	\hline
   	\end{tabular}
   	\label{ex_detec_cone}. The vertex obtained is $(2,0)$ and a cone direction is found: $(1,1)$ with the variable $y$.
\end{example}

The algorithm enumerates the linealty space when looking for a first vertex, and the cone and the vertices during Fukuda's algorithm: it allows to switch from an $H$-polyhedron to a $V$-polyhedron.



